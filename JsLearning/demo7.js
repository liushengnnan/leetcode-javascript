// // function foo() {
// //     console.log(a);
// //     a = 1;
// // }

// // foo(); // ???    //: ReferenceError: a is not defined

// function bar() {
//     a = 1;
//     console.log(a);
// }
// bar(); // ???   // 1 , a: 当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。


console.log(foo());

function foo(){
    console.log("foo");
}

var foo = 1;  

/// ??? // function foo(){ … }

// 会打印函数，而不是 undefined 。

// 这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。


// 变量对象会包括：

// 函数的所有形参 (如果是函数上下文)

// 由名称和对应值组成的一个变量对象的属性被创建
// 没有实参，属性值设为 undefined


// 函数声明

// 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
// 如果变量对象已经存在相同名称的属性，则完全替换这个属性


// 变量声明

// 由名称和对应值（undefined）组成一个变量对象的属性被创建；
// 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性